# 高级语言程序设计　期末资料与复习思路

## 有言在先：声明及警告

以下内容按照 CC0 协议发布。其仅应用于相互交流、讨论或学习，不得用于任何违法、违规或违纪之用途；违者自行承担全部责任和损失，自行为自己的前途负责。

以下内容尽力为期末复习提供思路和部分指引。若有疏漏之处或其它意见，欢迎讨论。

> [!NOTE]
> An alert of type 'note' using global style 'callout'.

## 谋定后动：面向期末复习，面向功能编程

回顾本学期的所学知识，似乎大多数都是 C 语言的各种语法和数据类型。也许在期末复习时，你也会翻开厚重的教材，按部就班地回忆整形与浮点、函数与指针等等知识……不可否认，这的确是一种非常稳扎稳打的复习方式。但是必须指出的是，面对逐渐逼近的期末压力，仅仅这样做的话效率太低下了。更何况，你也许已经注意到了：**并非所有知识点都会呈现在试题中，而试题的要求也往往可以通过多种手段实现**。因此，在确保自己已经掌握了足够的基础知识的前提下，我们完全没必要再采取机械的、回忆知识点的方式来复习。

由于期末的试题只有编程题，因此我们只需掌握 C 语言的具体应用，而不必关心诸如“运算符的优先级”“浮点数的存储方式”一类的细枝末节或语法规范——这就是“面向期末复习”的要义。更进一步地说，我们甚至可以不必复习“指针及其运用”“枚举类型的使用方法”等等内容，因为在现阶段，它们能解决的问题都可以使用更简单的数据结构（或类型）来完成。因此，**我们可以抛弃以知识点（或者数据类型）为单位的复习方式，转而以“功能”为单位复习所学知识**——我称之为“面向功能编程”（这当然是从“面向对象编程”改编过来的）。

本文正是以“面向期末复习，面向功能编程”为主线组织起来的。因此，在接下来的内容中，我将假定你已经具有理解下面代码片段的能力（拥有最低限度的知识是采用这种复习方式的重要前提），如果出现看不懂的地方，请及时对基础知识查漏补缺。特别地，本文除作为复习思路外，也可以作为期末资料使用。

## 天元机巧：常见功能要求及其实现

### 数据处理

#### 输入数据格式

可以充分利用scanf函数的格式控制符来把每个输入的数据赋值给对应的变量。更具体的细节在“字符与字符串-字符串读取”一节中介绍。

**注意：不要犯scanf("%d",num);或printf("%d",&num);一类的错误！**

> “……每行的格式为name1-name2: score1-score2表示两队比赛得分。其中在“:”“-”前后可能存在若干空格。每场得分不超过100分。”
>
> 下面就是用于读入一行数据的代码片段：
>
> ```c
> scanf("\n%[^-]-%[^:]:%d-%d",TeamNames[0],TeamNames[1],&Scores[0],&Scores[1]);
> ```
>
> 利用类似的方法，也可以控制scanf函数做各种各样的输入数据处理。

此外，还可以直接读取一整行输入，把它们当作字符数组来处理。

> “每个测试用例占一行，包含两个火星正整数A和B，火星整数的相邻两位数用逗号分隔，A和B之间有一个空格间隔。例如：23,4,53 5,4是一组测试用例。”
>
> 下面就是用于读入并处理一行数据的代码片段（火星整数的每一位都可能超过十进制的9）：
>
> ```c
> gets(che);//读入一行数据
>      while(che[n]!=' ')
>      {
>          if(che[n]!=',')
>          {
>              numche[nc]=che[n];//numche数组用于临时存放火星整数的一位
>              nc++;
>          }
>          else
>          {
>              numche[nc]='\0';
>              ma[ca]=atoi(numche);//atoi函数用于把字符串转换为整型
>              ca++;
>              nc=0;
>          }
>          n++;
>      }
>      numche[nc]='\0';
>      ma[ca]=atoi(numche);//这样，ma数组里的每个数就是火星正整数A的每一位了
>      ca++;
>      nc=0;
>      n++;
>      while(che[n]!='\0')
>      {
>          if(che[n]!=',')
>          {
>              numche[nc]=che[n];
>              nc++;
>          }
>          else
>          {
>              numche[nc]='\0';
>              mb[cb]=atoi(numche);
>              cb++;
>              nc=0;
>          }
>          n++;
>      }
>      numche[nc]='\0';
>      mb[cb]=atoi(numche);//这样，mb数组里的每个数就是火星正整数B的每一位了
> ```
>
> 利用类似的方法，也可以编写函数做各种各样的输入数据处理。

#### 分离数位

有时题目会需要我们能够把输入数字的每一位分离出来。这时可以采用如下的办法：

```c
int num[11];
scanf("%d",&fi);
while(fi!=0)
{
    num[count]=fi%10;
    fi=(fi-fi%10)/10;
    count++;
}
```

### 字符与字符串

#### 字符串读取

- scanf("%s",src);

  这个方法很常见，遇到空格和回车结束。当然，scanf也可以遇到空格不结束。

  %[]可以用来进行多个字符的输入,并对结束符进行自定义。对于%[]还可以用^+任意字符(包括 eof)来结束字符串的输入。

  比如%[ ^EOF]就是直到有EOF输入,字符串才中止。scanf("%[ ^\n]",src)就是直到输入回车键，读取才结束。**但是要注意，这样书写时，末尾的回车并没有被读取！例如，若下次使用scanf("%s",src);将读取到回车！**

- gets(src);

  gets()遇到空格不停止，遇到回车停止。**注意，最好不要混用scanf和gets！当先使用scanf再使用gets时，gets很可能会发生异常。这是因为输入字符串时，scanf遇到空格、回车、Tab结束，但在缓冲区中还留着这些结束符，此后如果使用gets想去获取下一行字符串，它碰到的却是前面遗留下来的空格、回车或Tab（或它们之前还有空格等空白符），那么这次gets就直接失效了。因此一定要混用时，必须先把前面的空白符读取并丢弃了再继续读取下面的内容！**

- 利用getchar()逐个读取字符进字符数组。

#### 大小写转换

> **使用部分库函数时不要忘记了写#include <ctype.h>或类似语句！**本文末尾有常用库函数列表。

C 库函数 int tolower(int c) 把给定的**字母**转换为小写字母。

C 库函数 int toupper(int c) 把小写**字母**转换为大写字母。

> 除了上述两种方法外，当然也可以自己实现。例如下面的函数确保返回值都是小写字母：
>
> ```c
> char strc(char a)
> {
>  if(a>='A'&&a<='Z')
>  {
>      a='a'-'A'+a;
>  }
>  return a;
> }
> ```
>
> 利用类似的方法，也可以编写函数判断传入的字符是否是小写字母、大写字母、数字……等。

#### 字符串拼接

C 库函数 char *strcat(char *dest, const char *src) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。

#### 字符串复制

C 库函数 char *strcpy(char *dest, const char *src) 把 src 所指向的字符串复制到 dest。

需要注意的是如果目标数组 dest 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。

#### 字符串比较

C 库函数 int strcmp(const char *str1, const char *str2) 把 str1 所指向的字符串和 str2 所指向的字符串进行比较。

- 如果返回值小于 0，则表示 str1 小于 str2。
- 如果返回值大于 0，则表示 str1 大于 str2。
- 如果返回值等于 0，则表示 str1 等于 str2。

#### 字符串查找

字符串查找也是常考内容。遇到这种问题，可以把字符串当成数组处理：

> 例：输入两个字符串str1和str2，判断字符串str1包含字符串str2的个数，允许重叠。
>
> ```c
> #include <stdio.h>
> #include <string.h>
> 
> int main()
> {
>  char d[512],x[512];
>  gets(d);
>  gets(x);
>  int dl=strlen(d);
>  int xl=strlen(x);
>  int count=0,flag=0;
>  for(int i=0;i<dl-xl+1;i++)
>  {
>      flag=0;
>      for(int j=0;j<xl;j++)
>      {
>          if(d[i+j]!=x[j])
>          {
>              flag=1;
>          }
>      }
>      if(flag==0)
>      {
>          count++;
>      }
>  }
>  printf("%d",count);
>  return 0;
> }
> ```

但要注意查找时是否允许重叠。例如下面的问题就不允许重叠：

> 例：请在输入的一段字符串里面查找给定的子串。另外子串不会重叠出现。
>
> ```c
> for(int i=0;i<GoalLen-TargetLen+1;i++)
>  {
>      Flag=0;
>      for(int j=0;j<TargetLen;j++)
>      {
>          if(tolower(Goal[i+j])!=tolower(Target[j]))
>          {
>              Flag=-1;
>              break;
>          }
>      }
>      if(Flag==0)
>      {
>          FindList[Count]=i;
>          Count++;
>          i=i+TargetLen-1;//正是这一行使我们查找的子串不允许重叠了
>      }
>  }
> ```

此外，可以使用 C 语言的库函数实现这一功能：

> strstr() 函数搜索一个字符串在另一个字符串中的第一次出现位置。找到所搜索的字符串，则该函数返回第一次匹配的字符串的地址；如果未找到所搜索的字符串，则返回NULL。
>
> ```c
> #include<stdio.h>
> #include<string.h>
> 
> int main()
> {
>  int i,n,j,k=0;
>  char a1[1001],a2[1001];
>  scanf("%s %s",a1,a2);
>  char *p;
>  p=a1;
>  while( ( p=strstr(p,a2) ) != NULL)//p为子串与母串匹配成功
>  {								  //时,子串第一个符号在母串
>      k++;						  //中出现的位置地址
>      p++; //p++后才能匹配下一个，否则无法退出循环
>  }
>  printf("%d",k);
> }
> ```

## 神算尽解：常见算法要求及其实现

> 这一部分是上述功能要求的补充，也是应该掌握的内容。

### 枚举

枚举是基于已有知识来猜测答案的一种问题求解策略。枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。说白了，**枚举就是暴力破解**。

> 例：一个数组中的数互不相同，求其中和为0的数对的个数。
>
> ```c
> for (int i = 0; i < n; ++i)
> for (int j = 0; j < n; ++j)
>  if (a[i] + a[j] == 0) ++ans;
> ```

### 模拟

模拟就是**用计算机来模拟题目中要求**的操作。模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。

写模拟算法的题目时，遵循以下的建议有可能会提升做题速度：

- 在动手写代码之前，在草纸上尽可能地写好要实现的流程。
- 在代码中，尽量把每个部分模块化，写成函数、结构体或类。
- 对于一些可能重复用到的概念，可以统一转化，方便处理。
- 调试时分块调试。模块化的好处就是可以方便的单独调某一部分。
- 写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。

实际上，上述步骤在解决其它类型的题目时也是很有帮助的。

> 例：一只长度不计的蠕虫位于n英寸深的井的底部。它每次向上爬u英寸，但是必须休息一次才能再次向上爬。在休息的时候，它滑落了d英寸。之后它将重复向上爬和休息的过程。蠕虫爬出井口需要至少爬多少次？如果蠕虫爬完后刚好到达井的顶部，我们也设作蠕虫已经爬出井口。
>
> ```c
> int main() {
> int n = 0, u = 0, d = 0;
> scanf("%d%d%d", &u, &d, &n);
> int time = 0, dist = 0;
> while (true) {  // 用死循环来枚举
>  dist += u;
>  time++;
>  if (dist >= n) break;  // 满足条件则退出死循环
>  dist -= d;
> }
> printf("%d\n", time);  // 输出得到的结果
> return 0;
> }
> ```
>
> 例：给定两个整数，求解这两个整数范围内的所有整数的倒数的总和。注意遇到整数0时，直接加上0。
>
> ```c
> #include <stdio.h>
> 
> double add(int n)
> {
>  if(n==0)
>  {
>      return 0;
>  }
>  else
>  {
>      return 1.0/(double)n;
>  }
> }
> 
> int main()
> {
>  int num=0;
>  scanf("%d",&num);
>  int f=0,s=0;
>  double ans=0;
>  for(int i=0;i<num;i++)
>  {
>      ans=0;
>      scanf("%d %d",&f,&s);
>      if(f>s)
>      {
>          f=f+s;
>          s=f-s;
>          f=f-s;
>      }
>      for(int j=f;j<=s;j++)
>      {
>          ans+=add(j);
>      }
>      printf("%.3f\n",ans);
>  }
>  return 0;
> }
> ```

### 递归

递归指**在函数的定义中使用函数自身**的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法。

递归代码最重要的两个特征是：**结束条件和自我调用**。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。

> 例：用递归求阶乘。
>
> ```c
> int fun(int a)
> {
> 	if(a<=1)
> 	return 1;
> 	return(a*fun(a-1));
> }
> ```
>
> 例：对于一个数n，如果是偶数，就把n砍掉一半；如果是奇数，把n变成 3*n+ 1后砍掉一半，直到该数变为1为止。计算需要经过几步才能将n变到1。
>
> ```c
> #include <stdio.h>
> int count=0;
> 
> void deal(int num)
> {
>  int n=num;
>  if(n==1)
>  {
>      return ;
>  }
>  else if(n%2==0)
>  {
>      count++;
>      deal(n/2);
>  }
>  else
>  {
>      count++;
>      deal((3*n+1)/2);
>  }
> }
> 
> int main()
> {
>  int num=0;
>  scanf("%d",&num);
>  int c=0;
>  for(int i=0;i<num;i++)
>  {
>      count=0;
>      scanf("%d",&c);
>      deal(c);
>      printf("%d\n",count);
>  }
>  return 0;
> }
> ```

### 排序

排序算法非常多。受时间和精力所限，我们将只简要介绍一种简单的排序算法——冒泡排序。

冒泡排序是一种简单的排序算法。由于在算法的执行过程中，较小的元素像是气泡般慢慢浮到数列的顶端，故叫做冒泡排序。它的工作原理是每次检查相邻两个元素，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。当没有相邻的元素需要交换时，排序就完成了。

经过 i 次扫描后，数列的末尾 i 项必然是最大的 i 项，因此**冒泡排序最多需要扫描 n-1 遍数组就能完成排序**。

> 冒泡排序的一个例子如下：
>
> ```c
> // 假设数组的大小是 n + 1，冒泡排序从数组下标 1 开始
> void bubble_sort(int *a, int n) {
> bool flag = true;//较低的 C 语言标准中不存在bool类型。这时可以使用int类型替代它。
> while (flag) {
>  flag = false;
>  for (int i = 1; i < n; ++i) {
>    if (a[i] > a[i + 1]) {
>      flag = true;
>      int t = a[i];
>      a[i] = a[i + 1];
>      a[i + 1] = t;
>    }
>  }
> }
> }
> ```

## 智妙明论：可能用到的扩展算法

> **以下算法可以不掌握。一般而言，它们只会出现在压轴题或类似难度的题目中。**至于此处未列出的其它算法，我猜测它们应该不会出现在题目中，故而不在此处写明。

### 搜索

搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。这里我们只介绍一种搜索方式：深度优先搜索。

DFS （即深度优先搜索）最显著的特征在于其**递归调用自身**。同时，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保**每个点仅访问一次**。符合以上两条规则的函数，便是广义上的 DFS。

DFS 核心结构的伪代码形式如下：

```
DFS(v)
  在 v 上打访问标记
  for u in v 的相邻节点
    if u 没有打过访问标记 then
      DFS(u)
    end
  end
end
```

> 例：给定一个整数a（0<=a<=5），求出a到a+4之间所有数的排列组合。
>
> ```c
> #include <stdio.h>
> 
> int f=0;
> int list[6];//用于存储访问标记。特别地，在这道题中，它也是要搜索的数据。
> 
> int iscan(int n,int p)//这一步正是检查是否有访问标记
> {
>  for(int i=1;i<p;i++)
>  {
>      if(list[i]==n)
>      {
>          return 1;
>      }
>  }
>  return 0;
> }
> 
> void r(int p)//这个函数正是用于执行搜索的函数
> {
>  if(p==6)
>  {
>      for(int j=1;j<6;j++)
>      {
>          printf("%d",list[j]);
>      }
>      printf("\n");
>      return;
>  }
>  else
>  {
>      for(int i=f;i<f+5;i++)
>      {
>          if(iscan(i,p)==0)
>          {
>              list[p]=i;
>              r(p+1);
>              list[p]=-2;
>          }
>      }
>  }
> }
> 
> int main()
> {
>  int num=0;
>  scanf("%d",&num);
>  for(int i=0;i<num;i++)
>  {
>      for(int j=0;j<6;j++)
>      {
>          list[j]=-2;
>      }
>      scanf("%d",&f);
>      r(1);
>  }
>  return 0;
> }
> ```
>
> 除了上面的例子外，搜索算法还有很多用处，例如解决“八皇后问题”等。

### 贪心

贪心算法，是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是**只看眼前，并不考虑以后可能造成的影响**。

可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。贪心算法有两种证明方法：反证法和归纳法。一般情况下，一道题只会用到其中的一种方法来证明。

- 反证法：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。
- 归纳法：先算出边界情况（例如 n=1）的最优解 ，然后再证明：对于每个 n，都可以由 n-1 推导出结果。这个证法与数学归纳法异曲同工。

> 例：假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？
>
> 用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。
>
> ```c
> #include<stdio.h>
> #include<stdlib.h>
> 
> int main() {
> 	int m[7]= {1,2,5,10,20,50,100}; //先有纸币的数额
> 	int k;
> 	//所找的金额
> 	int num;          //所需纸币的张数
> 	while((	scanf("%d",&k))!=EOF) {
> 		while(k>0) {
> 			if(k>=100) {
> 				k-=100;
> 			} else if(k>=50&&k<100) {
> 				k-=50;
> 			} else if(k>=20&&k<50) {
> 				k-=20;
> 			} else if(k>=5&&k<20) {
> 				k-=5;
> 			} else if(k>=2&&k<5) {
> 				k-=2;
> 			} else if(k>=1&&k<2) {
> 				k-=1;
> 			}
> 			num++;
> 		}
> 		printf("所需的张数为：%d\n",num);
> 	}
> }
> ```

### 动态规划

动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。

> 在题目中看到动态规划这种算法建议直接放弃此题——我不是在开玩笑。

## 容微纳芥：可能用到的扩展数据结构

> 以下内容不掌握。**下面的内容本质上是一本“词典”，只有当题目中出现相关内容时才需要查阅**。

数据结构大致包含以下几种存储结构：

- 线性表，还可细分为顺序表、链表、栈和队列；
- 树结构，包括普通树，二叉树，线索二叉树等；
- 图存储结构。

### 线性表

线性表结构存储的数据往往是可以依次排列的。就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。

> **在题目中看见线性表、顺序表、链表、栈或队列，往往可以直接当成数组。**

#### 顺序表

顺序表，简单地理解，就是常用的数组，只是换了个名字而已。

#### 链表

相比于顺序表，为了给各个数据建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL），就如同一个个小学生都伸手去拉住下一个小学生的手，这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表。

> 换言之，**链表可以用结构体实现**：每个结构体都包含数据本身和指向下一个元素的指针，这些结构体的集合即是链表。

#### 栈

栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。

#### 队列

队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。

### 树

> 下列内容应当看作是“词典”。也就是说，**下面的内容不需要阅读，只有题目中出现相关名词时才应该来查阅该名词的含义**。

树存储结构适合存储具有“一对多”关系的数据。

树是n（n>=0）个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：

1. 有且仅有一个特定的称为根的结点。
2. 当n>1时，其余节点可分为多个互不相交的有限集，其中每个集合本身又是一棵树，并且称为根的子树。

显然，树的定义是递归的，即在树的定义中又用到了自身，树是一种递归的数据结构。关于树，有如下术语：

- 考虑结点K。根A到结点K的唯一路径上的任意结点，称为结点K的祖先。例如，若结点B是结点K的祖先，则结点K是结点B的子孙。这条路径上最接近结点K的结点E称为K的双亲，而K为结点E的孩子。根A是树中唯一没有双亲的结点。有相同双亲的结点称为兄弟，例如，若结点K和结点L有相同的双亲E，则K和L为兄弟。
- 树中一个结点的孩子个数称为该结点的度，树中结点的最大度数称为树的度。
- 度大于0的结点称为分支结点（又称非终端结点）；度为0（没有子女结点）的结点称为叶子结点（又称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。
- 结点的层次从树根开始定义。根结点为第1层，它的子结点为第2层，以此类推。双亲在同一层的结点互为堂兄弟。
- 结点的深度是从根结点开始自顶向下逐层累加的。
- 结点的高度是从叶结点开始自底向上逐层累加的。
- 树的高度（或深度）树中结点的最大层数。
- 有序树和无序树。树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树；否则称为无序树。
- 路径和路径长度。树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。注意：由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的。同一双亲的两个孩子之间不存在路径。
- 森林。森林是多棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给多棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树。

#### 二叉树

二叉树是一种特定的树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。

如下是几个特殊的二叉树：

- 斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。

- 满二叉树：一棵树中的每层都含有最多的结点，这样的树叫满二叉树。
- 完全二叉树：高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。
- 平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1时，这样的树叫做平衡二叉树。

二叉树有如下几种遍历方式，它们都可以利用递归的方式实现：

- 先序遍历：
  若二叉树为空，则什么也不做，否则，
  1)访问根结点；
  2)先序遍历左子树；
  3)先序遍历右子树。
- 中序遍历：
  若二叉树为空，则什么也不做，否则，
  1)中序遍历左子树；
  2)访问根结点；
  3)中序遍历右子树。
- 后序遍历：
  若二叉树为空，则什么也不做，否则，
  1)后序遍历左子树；
  2)后序遍历右子树；
  3)访问根结点。

> 例：现在给出一棵二叉树，希望你输出它的中序遍历。
>
> ```c
> #include <stdio.h>
> 
> struct tree
> {
>  int num;
>  struct tree *le;
>  struct tree *ri;
> };
> 
> void read(struct tree *fi)
> {
>  if(fi->le!=NULL)
>  {
>      read(fi->le);
>  }
>  printf("%d ",fi->num);
>  if(fi->ri!=NULL)
>  {
>      read(fi->ri);
>  }
> }
> 
> int main()
> {
>  struct tree Trees[512];
>  int n=0,le,ri;
>  scanf("%d",&n);
>  for(int i=0;i<n;i++)
>  {
>      scanf("%d %d",&le,&ri);
>      Trees[i+1].num=i+1;
>      if(le!=-1)
>      {
>          Trees[i+1].le=&Trees[le];
>      }
>      else
>      {
>          Trees[i+1].le=NULL;
>      }
>      if(ri!=-1)
>      {
>          Trees[i+1].ri=&Trees[ri];
>      }
>      else
>      {
>          Trees[i+1].ri=NULL;
>      }
>  }
>  read(&Trees[1]);
>  return 0;
> }
> ```

### 图

图存储结构适合存储具有“多对多”关系的数据。

> 在题目中看到图这种数据结构建议直接放弃此题——我不是在开玩笑。

## 未雨绸缪：常用库函数列表

> **使用部分库函数时不要忘记了写#include <ctype.h>或类似语句！**

### #include <ctype.h>

| **函数原型说明**     | **功能**                               | **返回值**           |
| -------------------- | -------------------------------------- | -------------------- |
| int isalnum(int ch)  | 检查ch是否为字母或数字                 | 是，返回1；否则返回0 |
| int isalpha(int ch)  | 检查ch是否为字母                       | 是，返回1；否则返回0 |
| int isdigit(int ch)  | 检查ch是否为数字                       | 是，返回1；否则返回0 |
| int islower(int ch)  | 检查ch是否为小写字母                   | 是，返回1；否则返回0 |
| int isprint(int ch)  | 检查ch是否为包含空格符在内的可打印字符 | 是，返回1；否则返回0 |
| int isspace(int ch)  | 检查ch是否为空格、制表或换行符         | 是，返回1；否则返回0 |
| int isupper(int ch)  | 检查ch是否为大写字母                   | 是，返回1；否则返回0 |
| int isxdigit(int ch) | 检查ch是否为16进制数                   | 是，返回1；否则返回0 |
| int tolower(int ch)  | 把ch中的字母转换成小写字母             | 返回对应的小写字母   |
| int toupper(int ch)  | 把ch中的字母转换成大写字母             | 返回对应的大写字母   |

### #include <string.h>

| **函数原型说明**                   | **功能**                                                     | **返回值**                                                   |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| char *strcat(char *s1,char *s2)    | 把字符串s2接到s1后面                                         | s1所指地址                                                   |
| char *strchr(char *s,int ch)       | 在s所指字符串中，找出第一次出现字符ch的位置                  | 返回找到的字符的地址，找不到返回NULL                         |
| int strcmp(char *s1,char *s2)      | 对s1和s2所指字符串进行比较                                   | s1<s2,返回负数；s1= =s2,返回0；s1>s2,返回正数                |
| char *strcpy(char *s1,char *s2)    | 把s2指向的串复制到s1指向的空间                               | s1 所指地址                                                  |
| unsigned strlen(char *s)           | 求字符串s的长度                                              | 返回串中字符（不计最后的'\0'）个数                           |
| char *strstr(char *s1,char *s2)    | 在s1所指字符串中，找出字符串s2第一次出现的位置               | 返回找到的字符串的地址，找不到返回NULL                       |
| int stricmp(char *s1,char * s2)    | 比较字符串s1和s2，但不区分字母的大小写                       | s1<s2,返回负数；s1= =s2,返回0；s1>s2,返回正数                |
| char *strlwr(char *s)              | 将字符串s转换为小写形式                                      | s所指地址                                                    |
| char *strupr(char *s)              | 将字符串s转换为大写形式                                      | s所指地址                                                    |
| char *strrev(char *s)              | 把字符串s的所有字符的顺序颠倒过来（不包括空字符NULL）        | s所指地址                                                    |
| char *strtok(char *s, char *delim) | 分解字符串为一组标记串。s为要分解的字符串，delim为分隔符字符串 | 该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。 |

> strtok函数要获取后续的字符串，则把s改成NULL，并反复调用该函数。

### #include <math.h>

| **函数原型说明**                   | **功能**                                                     | **返回值**   |
| ---------------------------------- | ------------------------------------------------------------ | ------------ |
| int abs( int x)                    | 求整数x的绝对值                                              | 计算结果     |
| double fabs(double x)              | 求双精度实数x的绝对值                                        | 计算结果     |
| double modf(double val,double *ip) | 把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中 | 返回小数部分 |
| double pow(double x,double y)      | 计算x的y次方的值                                             | 计算结果     |
| float pow(float x, float y)        | 计算x的y次幂，只不过是float版本                              | 计算结果     |

### #include <stdlib.h>

| **函数原型说明**                          | **功能**                                                     | **返回值**                            |
| ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------- |
| char *itoa(int i)                         | 把整数i转换成字符串                                          | 结果                                  |
| double atof(const char *s)                | 将字符串s转换为double类型                                    | 结果                                  |
| int atoi(const char *s)                   | 将字符串s转换为int类型                                       | 结果                                  |
| long atol(const char *s)                  | 将字符串s转换为long类型                                      | 结果                                  |
| double strtod(char *s,char **ptr);        | 用于将字符串*s转换为浮点数。**ptr 为一字符串指针，用于进行错误检测，遇到非法字符将终止；如果 ptr 不为空，则指向转换中最后一个字符后的字符的指针会存储在ptr引用的位置。 | 转换后的浮点型数据，如果出错则返回0.0 |
| long strtol(char *s,char **ptr,int radix) | *s 为要转换的字符串，**ptr 为一字符串指针，用于进行错误检测，遇到非法字符将终止；如果 ptr 不为空，则指向转换中最后一个字符后的字符的指针会存储在ptr引用的位置。radix为采用的进制方式。 | 转换后的长整型数                      |

> 其它类型转换往往可以直接强制类型转换。例如：
>
> ```c
> int n=(int)2.34;  //n=2
> ```
